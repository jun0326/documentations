1、数据结构
	1、程序 = 数据结构 + 算法
	2、数据结构包括：线性结构和非线性结构
	3、线性结构其特点是一对一的线性关系，有线性存储和链性存储两种方式
	4、顺序表存储是有顺序的，链表存储是没有顺序的
	5、线性结构常见的有：数组、队列、链表和栈
	6、非线性结构：二维数组、多维数组、广义表、树结构、图结构
2、稀疏数组
	当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组
	 处理方法：
	 记录数组一共有几行几列，有多少个不同的值
	 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模值
	 二维数组转稀疏数组的思路
	 1、遍历原始的二维数组，得到有效数据的个数
	 2、根据sum就可以创建稀疏数组int[sum+1][3]
	 3、将二维数组的值村润稀疏数组
	 4、代码实现
	 稀疏数组转二维数组的思路
	 1、先读取第一行，根据第一行数据创建二维数组
	 2、然后将稀疏数组后几行读取出来，放进二维数组
	 3、代码实现
3、队列
	队列是一个有序列表，可以用数组或者链表来实现。
	遵循先入先出的原则
	数组实现
	数组最大容量 队列头 队列尾 数组用于存储数据，模拟队列
	代码实现：
		思路：
		1、front指向队列第一个元素的前一个位置，初始值为-1
		2、rear指向队列最后一个元素，初始值为-1
		问题:
		1、目前数组使用一次就不能使用了
		2、改进一个环形的队列实现，采用取模%方式
		
	数组模拟环形队列：
	思路
	1、front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素
	front初始值是0
	2、rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间做为约定。
	rear初始值是0
	3、当队列满时，条件是（rear+1）% maxSize == front
	4、当队列为空的条件，rear == front空
	5、当我们这样分析，队列中有效的数据的个数(rear+maxSize-front)%maxSize
4、链表
	链表是有序列表，
	1）链表是以节点的方式存储，是链式存储
	2）每个节点包含data域，next域：指向下一个节点
	3）发现链表的各个节点不一定是连续存储
	4）链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定
	
	单链表创建示意图，显示单向链表的分析
	添加（创建）
	1、先创建一个head头节点
	2、后面每添加一个节点，就直接加入到链表的最后
	遍历：
	1、通过一个辅助的变量，帮助遍历整个链表
	
	按照编号顺序来添加
	1、找到新添加节点的位置
	2、新的节点.next=temp.next
	3、将temp.next=新的节点
	
	单链表的修改
	单链表的删除思路
	1、我们先找到需要删除的这个节点temp
	2、temp.next = temp.next.next
	3、被删除的节点，将不会有其他引用，将会被垃圾回收
	
	单链表的常见面试题
	1）求单链表中有效节点的个数
	2）查找单链表中倒数第k个节点
	3）单链表的反转
	1、先定义一个节点reverseHead = new HeroNode();
	2、从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的前端
	3、原来的链表head.next = reverseHead.next
	4）从尾到头打印单链表（要求方式1：反向遍历。方式二：stack栈）
	方式一：先将单链表进行反转操作，然后遍历即可，这样做的问题是会破坏原来的单链表，不建议
	方式二：可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，实现了反向打印效果
	5）合并两个有序的单链表，合并之后的链表依然有序。
	
	双向链表
	单向链表存在的问题
	1、单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找
	2、单向链表不能自我删除，需要靠辅助节点，双向链表可以自我删除，单向链表删除时，需要一个temp节点，
	temp节点是删除节点的前一个节点
	
	思路：
	1）遍历方和单链表一样，只是可以向前，也可以向后查找
	2）添加（默认添加到双向链表的最后）
		1、先找到双向链表的最后这个节点
		2、temp.next = newHeroNode
		3、newHeroNode.pre = temp;
	3）修改思路和原理和单向链表一样
	4）删除
		1、双向链表，可以实现自我删除
		2、直接找到要删除的这个节点
		3、temp.pre.next = temp.next
		4、temp.next.pre = temp.pre
	作业：双向链表的第二种添加方式，按照编号顺序，按照单链表的顺序添加
	
	单向环形链表应用场景
	1）图形分析
		单向环形链表
	2）代码实现
		构建一个单向的环形链表思路
		1、先创建第一个节点，让first指向该节点，并形成环形
		2、后面当我们每创建一个新的节点，就把该节点加入到已有的环形链表中即可
		遍历环形链表：
		1、先让一个辅助指针（变量）curBoy,指向first节点
		2、然后通过一个while循环遍历该环形链即可curBoy.next == first 结束
		根据用户的输入，生成一个小孩出圈的顺序
		补充：小孩报数前，让first和helper移动k-1次
		1、需求创建一个辅助指针（变量）helper,事先应该指向环形链表的最后这个节点
		2、当小孩报数时，让first和helper指针同时的移动m-1次
		3、这时就可以将first指向的小孩节点出圈
		first = first.next
		helper.next = first
		原来first指向的节点就没有任何引用
		出圈顺序 2>4>1>5>3
5、栈（stack）
	一、栈理解
	1、栈的英文为（stack）
	2、栈是一个先入后出的有序列表
	3、栈是限制线性表中的插入和删除只能在线性表的同一端进行的一种特殊线性表。 
	允许插入和删除的一端，为变化的一端，称为栈顶，另一端为固定的一端，称为栈顶。
	4、根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素
	刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。
	
	二、实现栈的思路分析
	1、使用数组模拟栈
	2、定义一个top来表示栈顶，初始化为-1
	3、入栈操作，当有数据加入到栈时，top++：stack[top] = data;
	4、出栈操作，intvalue = stack[top]；top--,returnvalue
	
	课堂练习：用链表模拟栈
	
	使用栈完成计算一个表达式的结果
	数栈：存放数据
	符号栈：存放运算符
	思路：
	1、通过一个index值（索引），来遍历我们的表达式
	2、如果我们发现是一个数字，就直接让数栈
	3、如果发现扫描倒是一个符号，就分如下情况
	3.1 如果发现当前的符号栈为空，就直接入栈
	3.2 如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作复，就需要从数栈中出两个数，在从
	符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈
	如果当前的操作符优先级大于栈中的操作符，就直接入符号栈。
	4、当表达式扫描完毕，就顺序的从数栈和符号中pop出相应的数和符号，并运行
	5、最后在数栈只有一个数字，就是表达式的结果  
	
	如何处理多位数
	=============看到35集==============
	
	