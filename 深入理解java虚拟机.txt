课程介绍：
    本套课程从虚拟机的发展历史，虚拟机的内存结构，对象的分配与回收以及字节码，类加载等多个方面深入地对Java虚拟机进行了剖析。内容详实，语言通俗易懂。理论结合实践，让学习本套视频的朋友可以更快的理解虚拟机的原理，以解决虚拟机所带来的性能瓶颈以及由于虚拟机的不正当参数所导致各种问题。
    课程基于jdk7来讲解，环境是使用最新版jdk8，对于jdk8的新特性也会提及。课程以小节的形式发布，每个小节一个内容，每节尽可能独立。课程实战性强，以java虚拟机的内存结构为例，先讲了内存的结构，然后针对每个结构具体讲解。然后讲解监控工具，监控内存，线程等，然后讲三个案例贯穿整个内容
    就像使用浏览器打开网页，使用微信聊天一样，运行Java应用需要java虚拟机。我们似乎并不去关注浏览器是如何实现的，也不需要知道微信是如何通信的，我们只要根据其规则来使用就可以了。对于java虚拟机也是同样，因为虚拟机自身隐藏了底层技术的复杂性以及操作系统的差异性，开发者只需要了解其api，并不需要了解其内部原理就能够编写出可运行程序。
    然而，凡事都有两面性，当我们对于程序的性能，稳定性等等都有较高的要求的时候，这个时候看起来智能的虚拟机也就没这么智能了，我们就需要对虚拟机的内部结构深入了解之后，才能够根据业务需求，根据自身的情况设定合适的虚拟机参数，才能够让虚拟机高效稳定的运行。另外对于应用运行过程中出现的问题，也只有了解了虚拟机的结构之后才能够对问题进行准确定位。所以在java开发体系中，对系统调优师这一角色需求很大。学习虚拟机中各种运作特性的原理也成为java程序员成长道路上必然会接触到的一课。

课程目录：
	第1节说在前面的话 [免费观看] 00:05:07分钟  | 
	第2节整个部分要讲的内容说明 [免费观看] 00:06:58分钟  | 
	第3节环境搭建以及jdk,jre,jvm的关系 [免费观看] 00:20:48分钟  | 
	jdk包含编译器和jre，jre包含jvm,字节码是在jvm中运行的
	第4节jvm初体验-内存溢出问题的分析与解决 [免费观看] 00:17:59分钟	| 
	内存溢出工具处理 
	设置运行内存大小
	eclipse memory analyzer
	第5节jvm再体验-jvm可视化监控工具 [免费观看] 00:21:17分钟  | 
	jconsole.exe 代码在tools.jar中
	推内存 Eden new 对象 survivor 2  存活区 ，多次存活放在持久代中
	第6节杂谈 [免费观看] 00:12:37分钟  | 
	第7节Java的发展历史00:27:24分钟  | 
	1995 write once run anywhere
	1997 内部内 反射 jar文件格式 jdbc javabeans rmi
	1998 j2se j2me j2me swing jit hotspot vm
	2000 Timer 
	2002 jdk1.4 struts hibernate spring1.x、正则表达式、nio、日志、xml解析器
	2004 jdk1.5 自动装箱拆箱、泛型、注解、枚举、边长参数、增强for循环、spirng2.x spring4.x
	2006 jdk1.6 javase javame javaee jdk6 提供了编译api以及http服务器api、jdk开源
	2009 jdk1.7 oracle收购sun公司 74亿
	2011 jdk1.7
	2014 jdk1.8
	第8节Java的发展历史续00:02:27分钟  | 
	第9节Java技术体系00:08:46分钟  | 
	第10节jdk8的新特性00:07:31分钟  | 
	lanmdba表达式和函数式编程
	Date API
	重复注解
	第11节lanmbda表达式简介00:07:02分钟  | 
	第12节Java虚拟机-classic vm00:06:06分钟  | 
	虚拟机产品发展
	Sun Classic VM 第一款商用，只能使用纯解释器的方式执行
	Sun hotspot bea JRockit IBM J9
	第13节Java虚拟机-ExactVM00:03:35分钟  | 
	Exact VM  编译器和解释器混合工作以及两级即时编译器
	第14节Java虚拟机-HotSpotVM00:04:23分钟  | 
	2006年后成为最佳虚拟机产品，官方虚拟机
	第15节Java虚拟机-kvm00:03:04分钟  | 
	嵌入式虚拟机产品，在手机平台运行
	第16节Java虚拟机-JRockit00:04:12分钟  | 
	BEA 世界上最快的java虚拟机，专注服务端应用，优势 垃圾收集器
	第17节Java虚拟机-j900:04:23分钟  | 
	IBM J9
	第18节Java虚拟机-dalvik00:02:20分钟  | 
	安卓平台，不是java虚拟机，不能执行java文件，执行Dex文件
	第19节Java虚拟机-MicrosoftJVM00:03:57分钟  | 
	
	第20节Java虚拟机-高性能Java虚拟机00:02:58分钟  | 
	Azul VM Liquid VM
	第21节Java虚拟机-TaobaoVM00:03:06分钟  | 
	深度定制的产品，损失兼容性，提高性能
	第22节Java内存区域-简介00:07:56分钟  | 
	虚拟机内存管理
	运行时数据区
	线程共享区：
	方法区：存储运行时常量池、已被虚拟机加载的类信息，常量、静态常量
	堆：存储对象实例
	线程独占区：
	虚拟机栈：存放方法运行时所需要的数据，成为栈帧
	本地方法区：为JVM所调用到的native方法，即本地方法服务
	程序计数器：记录当前线程执行到的字节码行号
	
	
	第23节Java内存区域-Java虚拟机栈00:12:04分钟  | 
	1、java方法执行的动态内存模型
	2、栈帧：每个方法执行，都会创建一个栈帧，用于存储局部变量表等
	3、局部变量表：存放编译器可知的各种基本数据类型、引用类型
	局部变量表的内存空间在编译器完成分配的，后期不会改变
	4、大小
	没有规定大小，申请不了内存 OutOfMemory 
	先进后出的一种方式
	异常 stackOverFlowError 栈内存溢出，递归出现这个问题
	第24节Java内存区域-程序计数器00:12:54分钟  | 
	1、比较小的内存空间，当前字节码执行行号指示器
	2、存于线程独占区
	3、如果执行的是native方法，这个计数器的值为undefined
	4、任何规定内存溢出的唯一区域
	5、goto指定跳到某一行，不用了
	第25节Java内存区域-本地方法栈00:02:39分钟  | 
	为虚拟机执行native方法
	第26节Java内存区域-堆内存00:05:08分钟  | 
	jvm管理的一个最大的内存区域
	存放对象实例
	垃圾收集器管理的主要区域
	新生代、老生代、Eden空间
	OutOfMemory异常
	-Xmx -Xms
	第27节Java内存区域-方法区00:06:32分钟  | 
	1、类信息（类的版本、字段、方法、接口）
	2、方法区和永久代（hostport使用永久代替代方法区）
	3、垃圾回收在方法区的行为 （常量池回收）
	4、异常的定义
	OutOfMemory
	第28节Java内存区域-直接内存和运行时常量池00:15:53分钟  | 
	运行时常量池属于方法区的一部分
	StringTable:HashSet 字符串放在字符串表中
	new 对象 是放在堆中的 
	intern() 方法表示运行时常量
	直接内存
	第29节对象在内存中的布局-对象的创建00:21:19分钟  | 
	对象创建过程
		先检查，如果没有，则进行类的加载、解析和初始化
		虚拟机为对象分配内存（位于堆中）
	1、给对象分配内存
		a.指针碰撞
			内存分为已用和未使用
		b.空闲列表
	2、线程安全性问题
		a、实现线程同步，加锁，效率低
		b、本地线程分配缓冲
	3、初始化对象
		
	4、执行构造方法
	第30节探究对象的结构00:13:47分钟  | 
	1、Header
	自身运行时数据
	 哈希值（Object的native方法） GC分代年龄 锁状态标志  线程持有的锁 偏向线程ID
	类型指针
	 
	2、InstanceData
	 Longs/doubles   shorts/chars
	3、Padding
	要求数据是8个字节整数位，填充、补位作用
	第31节深入理解对象的访问定位00:08:01分钟  | 
	1、使用句柄
	优势：栈引用的地址不需要改变
	一般保持对象实例数据的指针
	保持对象数据类型的指针
	2、使用直接指针（hostport使用该方式）
	直接指向对象
	保持对象数据类型的指针
	第32节垃圾回收-概述00:06:20分钟  | 
	1、如何判定对象为垃圾对象
		引用计数法
		可达性分析法
	2、如何回收
		回收策略
			标记-清除算法
			复制算法
			标记-整理算法
			分代收集算法
	3、何时回收
		serial
		parnew
		cms
		g1
	第33节垃圾回收-判断对象是否存活算法-引用计数法详解00:14:08分钟 |
		引用计数算法
		在对象中添加一个引用计数器，当有一个引用的时候+1，引用失效的时候-1，当外部没有引用，内部有引用时，
		垃圾回收器并没有回收
		-verbose:gc
		-xx:+PringGCDetail
	第34节垃圾回收-判断对象是否存活算法-可达性分析法详解00:07:09分钟  | 
	    作为GCRoots的对象
		虚拟机栈
		方法区的类属性所引用的对象
		方法区中常量所引用的对象
		本地方法栈中引用的对象
		有一个GcRoot根节点
	第35节垃圾回收算法-标记清除算法00:04:36分钟  | 
		1、标记
			效率问题
			空间问题
		2、清除
	第36节垃圾回收算法-复制算法00:14:35分钟  | 
		堆内存：
			新生代：
				Eden 伊甸园  1 占用内存80%
				Survivor 存活区 2 各占10%
				Tenured Gen  1
			老年代
	推内存分为使用和未使用
	问题：造成内存资源浪费
	第37节垃圾回收算法-标记整理算法和分代收集算法00:05:24分钟  | 
	标记整理算法针对老年代
	第38节垃圾收集器-serial收集器详解00:09:45分钟  | 
	1、最基本、发展最悠久的
	2、单线程垃圾回收器
	3、桌面应用上
	第39节垃圾收集器-parnew收集器详解00:04:53分钟  | 
	1、多线程
	第40节垃圾收集器-parallel收集器详解00:11:02分钟  | 
	1、复制算法（新生代收集器）
	2、多线程收集器
	3、到达可控制的吞吐量：CPU用于运行用户代码的时间与CPU消耗的总时间比值
	-XX:MaxGCPauseMillis 垃圾收集器最大的停顿时间
	-XX:GCTimeRatio 吞吐量大小,默认值是99，最大也是99
	第41节垃圾收集器-cms收集器详解00:14:58分钟  | 
		工作过程
			初始标记
			并发标记
			重新标记
			并发清理
		优点
			并发收集
			低停顿
		缺点
			占用大量的CPU资源
			无法处理浮动垃圾
			出现Concurrent Mode Failure
			空间碎片
	第42节最牛的垃圾收集器-g1收集器详解00:18:04分钟  | 
	历史
	 2004年出现
	优势
	 并行与并发
	 分代收集
	 空间整合
	 可预测的停顿
	步骤
	初始标记
	并发标记
	最终标记
	筛选回收
	与cms比较
	第43节内存分配-概述00:04:23分钟  | 
	内存分配策略
	1、优先分配到eden
	2、大对象直接分配到老年代
	3、长期存活的对象分配到老年代
	4、空间分配担当
	第44节内存分配-Eden区域00:22:51分钟  | 
	1、对象优先在Eden上分配
	第45节内存分配-大对象直接进老年代00:06:42分钟  | 
	2、大对象直接进入老年代
	-XX:PretenureSizeThreshold 指定老年代内存
	第46节内存分配-长期存活的对象进入老年代00:03:40分钟  | 
	3、长期存活的对象分配到老年代
	-XX:MaxTenuringThreshold 15
	第47节内存分配-空间分配担保00:04:54分钟  | 
	4、空间分配担当
	-XX:+HandlePromotionFailure  前面+号开启 -号关闭
	第48节内存分配-逃逸分析与栈上分配00:10:32分钟  | 
	逃逸分析：分析对象的作用域
	方法返回，发生逃逸
	为成员属性赋值，发生逃逸
	对象的作用域仅在当前方法中有效，没有发生逃逸
	引用成员变量的值，发生逃逸
	栈上分配
	第49节虚拟机工具介绍00:10:27分钟  | 
	
	第50节虚拟机工具-jps详解00:11:20分钟  | 
	java process status java进程管理器
	本地虚拟机唯一id 
	jps -l 主类全名
	jps -m 运行时参数
	jps -v  虚拟机参数
	jps -mlv
	第51节虚拟机工具-jstat详解00:09:20分钟  | 
	类装载、内存、垃圾收集、
	jstat 类似端口号
	-gcutil
	第52节虚拟机工具-jinfo详解00:05:03分钟  | 
	jinfo -flag UseSerialGC 8264
	jinfo -flag UseG1GC 8264	
	第53节虚拟机工具-jmap详解00:08:48分钟  | 
	jmap 在window下支持的参数并不多
	
	jmap -dump：format=b,file=c:\a.bin 8264
	第54节虚拟机工具-jhat详解00:08:10分钟  | 
	JVM heap Analysis Tool
	jhat d:\a.bin
	进入图形化界面
	第55节虚拟机工具-jstack详解00:10:19分钟  | 
	线程快照
	jstack -l 8264
	指定线程的名字
	第56节可视化虚拟机工具-Jconsole内存监控00:07:09分钟  | 
	jconsole 内存监控
	第57节可视化虚拟机工具-Jconsole线程监控00:12:18分钟  | 
	线程监控
	第58节死锁原理以及可视化虚拟机工具-Jconsole线程死锁监控00:10:38分钟  | 
	资源A\B 线程1\2
	第59节VisualVM使用详解00:08:03分钟  | 
	插件地址 https://visualvm.github.io
	第60节性能调优概述00:11:22分钟  | 
	第61节性能调优-案例100:23:28分钟  | 
	问题：
	经常有用户反映长时间出现卡顿的现象
	处理思路
	1、优化sql（方向不对）
	2、监控CPU (方向不对)
	3、监控内存
		Full GC 20-30s 垃圾回收时间长
	解决方案
		部署多个web容器，每个web容器的推内存指定为4g
	总结经验
	第62节性能调优-案例200:10:05分钟  
	场景
	爬虫抓取数据，派发到其他系统| 
	问题：不定期内存溢出，把堆内存加大，也不行。导出堆转储快照，没有任何信息，内存监控，正常。
	处理思路
	总结经验
	
	第63节性能调优-案例300:12:41分钟  | 
	
	物联网应用
	问题：JVM崩溃了  报错信息 Connect Reset
	处理思路
	大量数据过来了，jvm数据服务器处理不了，采用消息队列来处理。
	第64节前半部分内容整体回顾00:15:41分钟  | 
	
	第65节Class文件简介和发展历史 [免费观看] 00:11:26分钟  | 
	javac jdk自带的编译器
	问题：idea、eclipse 编译java代码，是使用javac吗
	
	第66节Class文件结构概述 [免费观看] 00:16:50分钟  | 
    Class文件是一组以8位字节为基础单位的二进制文件，效率高，占内存少
	当遇到8位字节以上的空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。
	Class文件有两种数据类型，分别是无符号数和表。
	例子：
	大量数据可以采用二进制方式处理
	二进制和文本存储的比较
	
	文件结构
	魔数
	Class文件版本
	常量池
	访问标志
	类索引，父类索引
	第67节Class文件设计理念以及意义 [免费观看] 00:13:41分钟  | 
	语法规范 --》 编译器 --》 字节码规范  --》虚拟机运行
	运行在jvm之上的语言：Clojure、groovy、Jruby,Jytho,Scala
	第68节文件结构-魔数 [免费观看] 00:09:49分钟  | 
	jvm执行区分类型不是通过文件后缀名去区分的,而是根据魔数去处理
	魔数
	CA FE BA BE 
	版本
	34 16进制转成 12进制 52 是jdk1.8
	第69节文件结构-常量池 [免费观看] 00:23:44分钟  | 
	CP_info  --没看懂
	第70节文件结构-访问标志 [免费观看] 00:11:36分钟  | 
	--没看懂
	第71节文件结构-类索引00:11:26分钟  | 
	--没看懂
	第72节文件结构-字段表集合00:13:21分钟  | 
	--没看懂
	第73节文件结构-方法表集合00:10:06分钟  |  --没看
	第74节文件结构-属性表集合00:18:23分钟  |  --没看
	工具查看命令 javap -verbose xx.class
	
	第75节字节码指令简介00:09:18分钟  | 
	java虚拟机的指令有一个字节长度的，代表者某种特定操作含义的数字。
	操作码的长度为1，最大只有256个
	基于栈的指令集架构
	第76节字节码与数据类型00:09:34分钟  | 
	在虚拟机集中指令中，大多数的指令都包含了器作所对应的数据类型
	Iload fload
	
	也有不包含类型信息的
	Goto 与类型无关
	Arraylength 操作数组类型
	类型多，指令少
	第77节加载指令00:09:33分钟  | 
	
	第78节运算指令00:10:24分钟  | -- 没看
	第79节类型转换指令00:13:42分钟  | --没看
	第80节对象创建与访问指令00:09:38分钟  | --没看
	
	第81节操作树栈指令00:03:27分钟  |  --没看
	第82节控制转移指令00:11:58分钟  |  --没看
	第83节方法调用和返回指令00:06:37分钟  | --没看 
	第84节异常处理指令00:09:44分钟  | --没看
	第85节同步指令00:07:34分钟  | --没看
	
	第86节类加载机制概述00:07:26分钟  | 
	虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成
	可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。
	采用懒加载机制 
	第87节类加载时机00:13:15分钟  | 
	加载
	懒加载机制
	连接 包括验证 准备 解析 
	加载开始之后，连接就开始了，但是必须是加载结束了，才能连接结束
	初始化
	new getstatic putstatic invokestatic
	java.lang.reflect包的方法对类进行反射
	初始化一个类的时候，如果其父类还没初始化，则先初始化其父类
	当虚拟机启动时，需要指定一个带main方法的主类
	
	通过子类引用父类的静态字段，子类不会被初始化
	通过数组定义来引用类 父子类不会初始化
	调用类的常量 父子类不会初始化
	使用
	卸载
	第88节类加载的过程-加载00:15:15分钟  | 
	通过一个类的全限定类名获取定义此类的二进制流
		加载源：
			文件
				class文件
				jar文件
			网络
			计算生成一个二进制流
			$Proxy
	将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
	在内存中生成一个代表这个类的Class对象，作为这个类的各种数据访问入口
	Class对象放到方法区中
	第89节类加载的过程-验证00:10:24分钟  | 
	对字节码文件进行验证
	验证是连接的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的规范
	 并不会危害虚拟机的安全，可以指定参数跳过验证过程
		文件格式
		元数据
		字节码
		符号引用
	第90节类加载的过程-准备00:05:40分钟  | 
	准备阶段正式为变量分配内存并设置变量的初始值，这些变量使用的内存都将在方法区中进行分配。
	这里的初始值并非指定的值，而是指默认的值，但是如果被final修饰，则为指定的值。
	第91节类加载的过程-解析00:14:04分钟  | 
	解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程
		类或者接口的解析
		字段解析
		类方法解析
		接口方法解析
	第92节类加载的过程-初始化00:19:41分钟  | 
	初始化阶段是执行类构造器<client>()方法
	init是线程安全的
	静态块中的变量，前面的变量可以定义，也可以引用，后面的变量可以定义，但是静态块中不可以引用
	第93节类加载器00:22:41分钟  | 
	通过类全限定名获取此类的二进制字节流，这个动作放到虚拟机外部实现
	由相同类加载器加载的字节码文件才会出现相同的信息
	
	启动类加载器
	c++实现，是虚拟机的一部分，用于加载javahome目录下lib文件类
	扩展类加载器
	加载javahome下/lib/ext目录中的类
	应用程序类加载器
		加载用户指定应用程序的类库
	自定义类加载器
	继承ClassLoader
	
	第94节双亲委派模型00:17:03分钟  | 
	这些类加载器是如何协同工作的
	启动类加载器 rt.jar
	扩展类加载器
	应用程序类加载器
	自定义类加载器
	
	每一层类加载器都会往上抛
	如果任何一层类加载器都没有方法加载，就会报ClassNotFound
	
	第95节运行时栈帧结构00:08:46分钟  | 
	局部变量表
	操作数栈
	动态链接
	返回地址
	...
	帧栈n
	第96节局部变量表00:20:48分钟  | 
	局部变量是要赋值才能使用
	
    slot(变量槽)
	
	多线程
	要有共享资源
	对共享资源进行非原子性操作
	A--(不是非原子类型操作)
	
	slot 复用
	当一个变量的pc寄存器的值大于slot的作用域的时候，slot是可以复用的
	第97节操作数栈00:08:36分钟  | 
	通过压栈和弹栈来操作
	第98节动态连接00:02:56分钟  | 
	相对静态连接，动态指定调用方法
	第99节方法返回地址和附加信息00:03:24分钟  | 
	方法返回值
	第100节方法调用-解析调用00:09:49分钟  | 
	三大特性：封装、继承、多态
	方法调用并不等同于方法的执行，方法调用阶段的唯一任务就是确定被调用方法的版本
	静态方法 构造器方法 私有方法 final修饰的方法
	
	第101节方法调用-静态分派调用00:16:21分钟  | 
	Parent p1 = new Child1();
	父类引用指向子类实例 父类是静态类型，静态类型在编译的时候就已经确定了
	
	实际类型发生改变
	Parent p1 = new Child1();
	p1 = new ew Child2();
	
	静态类型发生变化
	d.sayHello((Child2) p);
	
	主要是方法的重载 静态分派调用
	
	第102节方法调用-动态分派调用00:09:02分钟  | 
	主要是方法的重写 动态分派调用
	找到操作数栈顶的第一个元素所指向的对象的实际类型，在实际类中先找，实际类型找不到，就往父类找
	，如果始终没有找到，则抛出AbstractMethodError
	
	第103节动态类型语言支持00:09:27分钟  | 
	静态类型语言在非运行阶段，变量的类型是可以确定的，
	动态类型语言在非运行阶段，变量的类型是无法确定的，也就是变量是没有类型的
	但是值是有类型的，也就是运行期间可以确定变量的值的类型
	第104节字节码执行引擎小结00:03:38分钟  | 
	
	第105节总结与回顾00:10:55分钟  | 
	第106节happens-before简单概述00:15:17分钟  | 
	用来指定两个操作之间的执行顺序。提供跨线程的内存可见性
	在java内存模型中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必然存在happens-before关系
	规则如下
	程序顺序规则
	监听器锁规则
	对于一个锁的解锁，总是happens-before于随后对这个锁的加锁
	volaitle变量规则
	对于一个volaitle的写，总是happens-before于对volaitle的读
	传递性
	start规则
	join规则
	第107节重排序问题00:23:19分钟  | 
	什么是重排序
	是对指令的重新排序，保证程序运行的正常
	编译器和处理为了提高程序运行的性能，对指令重新排序
	数据依赖性问题
	写后读
	读后写
	写后写
	指令重排序分类
		编译器重排序和处理器重排器
	为什么要进行指令重排序
	指令重排序所带来的影响
	单线程：保证结果一致性没问题
	多线程：可能存在结果不一致问题
	竞争与同步
	第108节锁的内存语义00:13:54分钟  | 
	锁的释放与获取建立的happens-before关系
	锁的释放和获取的内存语义
    锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息
	第109节volatile的内存语义00:12:04分钟  | 
    volatile：读和写
	当写一个volatile变量时，java内存模型会把该线程对应的本地内存中的共享变量值刷新到内存中存储
	当读一个volatile变量时，java内存模型会把当前线程对应的本地内存中的共享变量置为无效，然后从主内存中读取
	第110节final域内存语义00:34:07分钟  | 
	
	写final域的重排序规则
	写final域的重排序规则禁止把final域的写，重排序到构造方法之外
	Java的内存模型禁止编译器把final域的重写排序到构造方法之外,在构造方法
	执行完毕之前，插入一个内存屏障StoreStore,保证处理器把final域的写操作在构造方法中执行
	内存屏障
	LoadLoad
	StoreStore
	LoadStore
	StoreLoad
	
	读final域的重排序规则
	在一个线程中，初次读对象引用和初次读该对象所包含的final域，java内存模型禁止处理器重排序着两个操作。
	
	final域为抽象类型
	在构造方法内对一个final引用的对象的成员域的写入，与随后在构造方法外把这个
	被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。